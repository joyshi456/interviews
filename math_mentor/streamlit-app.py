# simple_app.py - Simplified version focusing only on core functionality
import streamlit as st
import sympy as sp
import re
import time
import random
from problem_bank import generate_problem, solve_integral, x, safe_sympify

# ----------------- session state -----------------
if "prob" not in st.session_state:
    st.session_state.prob = None
if "level" not in st.session_state:
    st.session_state.level = 1

# ----------------- app layout -----------------
st.title("üß† Integration Practice")
st.write("Solve the integral below:")

# Generate or retrieve current problem
if st.session_state.prob is None:
    try:
        # Set a random seed based on current time to ensure different problems
        random.seed(int(time.time() * 1000))
        
        # Generate the problem
        st.session_state.prob = generate_problem(st.session_state.level)
        
        # Display the problem ID for debugging
        st.session_state.problem_id = f"Problem ID: {int(time.time())}"
        st.sidebar.text(st.session_state.problem_id)
    except Exception as gen_err:
        st.error(f"Error generating problem: {gen_err}")
        # Create a simple fallback problem
        st.session_state.prob = {
            "latex": r"\int x \,dx",
            "sympy": x
        }

# Show problem
st.subheader("Solve this integral:")
try:
    st.latex(st.session_state.prob["latex"])
    
    # Display the source of the problem (Gemini or fallback)
    if "source" in st.session_state.prob:
        source = st.session_state.prob["source"]
        if source == "gemini":
            st.success("‚úÖ Problem generated by Gemini API")
        elif source == "fallback":
            st.warning("‚ö†Ô∏è Using fallback problem (Gemini API unavailable)")
        elif source == "ultimate_fallback":
            st.error("‚ùå Using ultimate fallback (all other methods failed)")
except Exception as latex_err:
    st.error(f"Error displaying problem: {latex_err}")
    st.write("Problem: Integrate x with respect to x")

# Answer input (outside of form for better reactivity)
answer = st.text_input("‚à´ = ")

# Buttons
col1, col2 = st.columns(2)
submit_button = col1.button("Submit Answer")
new_problem_button = col2.button("New Problem")

# Process answer submission
if submit_button:
    if not answer.strip():
        st.error("‚ö†Ô∏è Please enter an answer before submitting.")
    else:
        # Get the correct answer using SymPy
        try:
            correct_expr = solve_integral(st.session_state.prob["sympy"])
            correct_latex = sp.latex(correct_expr) + " + C"
            
            # Parse the user's answer - handle common syntax errors
            try:
                # Pre-process common syntax errors
                processed_answer = answer
                
                # Handle implicit multiplication (e.g., 2x ‚Üí 2*x)
                processed_answer = re.sub(r'(\d)([a-zA-Z])', r'\1*\2', processed_answer)
                
                # Try to parse the processed answer
                user_expr = safe_sympify(processed_answer)
                
                # If the processed answer is different from the original, inform the user
                if processed_answer != answer:
                    st.info(f"Note: Your input '{answer}' was interpreted as '{processed_answer}'")
            
                # Check if the difference is a constant (derivative would be 0)
                diff = sp.simplify(user_expr - correct_expr)
                is_constant = sp.diff(diff, x) == 0
                
                # Display results
                st.write("### Answer Check:")
                st.write(f"Your answer: ${sp.latex(user_expr)}$")
                st.write(f"Correct answer: ${correct_latex}$")
                
                if diff == 0 or is_constant:
                    st.success("‚úÖ Correct! Your answer is equivalent to the correct solution.")
                else:
                    st.warning("‚ùå Incorrect. Your answer differs from the expected solution.")
                    
                # Debug info in an expander
                with st.expander("Debug Details"):
                    st.write(f"Difference: ${sp.latex(diff)}$")
                    st.write(f"Is constant: {is_constant}")
                    
            except Exception as parse_err:
                st.error(f"‚ö†Ô∏è Could not parse your answer: {parse_err}")
                st.info("Make sure you're using valid SymPy syntax. For example, use 'x**2' for x¬≤, 'sin(x)' for sine, etc.")
                
        except Exception as solve_err:
            st.error(f"‚ö†Ô∏è Error solving the integral: {solve_err}")
    
# Handle new problem button
if new_problem_button:
    # Force a new problem by setting prob to None and adding a timestamp to ensure uniqueness
    st.session_state.prob = None
    st.session_state.problem_timestamp = time.time()  # Add a timestamp to force a new problem
    st.rerun()

# Syntax help
with st.expander("SymPy Syntax Help"):
    st.markdown("""
    ### SymPy Syntax Tips
    - Use `x**2` for x¬≤
    - Use `sin(x)`, `cos(x)`, `tan(x)` for trigonometric functions
    - Use `exp(x)` for e^x
    - Use `log(x)` for natural logarithm
    - Use `sqrt(x)` for square root
    - Use `pi` for œÄ
    - Use `2*x` for 2x (explicit multiplication)
    """)

# Difficulty selector
st.sidebar.header("Settings")
level = st.sidebar.radio(
    "Difficulty Level",
    [1, 2, 3],
    index=st.session_state.level - 1,
    format_func=lambda x: {1: "üü¢ Easy", 2: "üü° Medium", 3: "üî¥ Hard"}[x]
)

if level != st.session_state.level:
    st.session_state.level = level
    st.session_state.prob = None
    st.rerun()
